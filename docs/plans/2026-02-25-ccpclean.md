# ccpclean Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a cross-platform Rust CLI tool that scans running processes for orphaned local web services and lets the user kill them via an interactive TUI.

**Architecture:** `scanner.rs` uses `sysinfo` + `netstat2` to build a `Vec<ProcessInfo>` with ports, memory, parent info, and uptime. `filter.rs` scores and filters them. `tui/` renders two switchable views (list-select + two-panel detail) using `ratatui` + `crossterm`. `killer.rs` terminates selected processes cross-platform.

**Tech Stack:** Rust, `sysinfo 0.32`, `netstat2 0.2`, `ratatui 0.29`, `crossterm 0.28`, `clap 4`

---

### Task 1: Project Scaffold

**Files:**
- Create: `Cargo.toml`
- Create: `src/main.rs`

**Step 1: Initialize the project**

```bash
cd /c/Users/40728/codes/ideas/clean-my-process
cargo init --name ccpclean
```

Expected: `Cargo.toml` and `src/main.rs` created.

**Step 2: Replace `Cargo.toml` with full dependencies**

```toml
[package]
name = "ccpclean"
version = "0.1.0"
edition = "2021"
description = "Scan and clean up orphaned local web service processes"
license = "MIT"
repository = "https://github.com/YOUR_USERNAME/ccpclean"
keywords = ["process", "cli", "tui", "devtools", "cleanup"]
categories = ["command-line-utilities", "development-tools"]

[[bin]]
name = "ccpclean"
path = "src/main.rs"

[dependencies]
sysinfo = "0.32"
netstat2 = "0.10"
ratatui = "0.29"
crossterm = "0.28"
clap = { version = "4", features = ["derive"] }

[profile.release]
strip = true
opt-level = 3
```

**Step 3: Verify it compiles**

```bash
cargo build
```

Expected: compiles with no errors (warnings OK).

**Step 4: Commit**

```bash
git add Cargo.toml src/main.rs
git commit -m "chore: scaffold ccpclean project"
```

---

### Task 2: ProcessInfo Struct

**Files:**
- Create: `src/process_info.rs`
- Modify: `src/main.rs` (add `mod process_info;`)

**Step 1: Create `src/process_info.rs` with the struct and tests**

```rust
use std::time::{Duration, SystemTime, UNIX_EPOCH};

#[derive(Debug, Clone)]
pub struct ProcessInfo {
    pub pid: u32,
    pub name: String,
    pub cmd: Vec<String>,
    pub ports: Vec<u16>,
    pub start_time_secs: u64, // seconds since Unix epoch
    pub memory_kb: u64,
    pub parent_pid: Option<u32>,
    pub parent_name: Option<String>,
    pub is_dev_runtime: bool,
    pub score: u8,
}

impl ProcessInfo {
    pub fn uptime(&self) -> Duration {
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();
        let elapsed = now.saturating_sub(self.start_time_secs);
        Duration::from_secs(elapsed)
    }

    pub fn uptime_display(&self) -> String {
        let secs = self.uptime().as_secs();
        if secs < 60 {
            format!("{}s ago", secs)
        } else if secs < 3600 {
            format!("{}m ago", secs / 60)
        } else {
            format!("{}h {}m ago", secs / 3600, (secs % 3600) / 60)
        }
    }

    pub fn memory_display(&self) -> String {
        if self.memory_kb < 1024 {
            format!("{} KB", self.memory_kb)
        } else {
            format!("{:.1} MB", self.memory_kb as f64 / 1024.0)
        }
    }

    pub fn ports_display(&self) -> String {
        self.ports
            .iter()
            .map(|p| p.to_string())
            .collect::<Vec<_>>()
            .join(", ")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn make_process() -> ProcessInfo {
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();
        ProcessInfo {
            pid: 1234,
            name: "node".to_string(),
            cmd: vec!["node".to_string(), "server.js".to_string()],
            ports: vec![3000, 3001],
            start_time_secs: now - 7380, // 2h 3m ago
            memory_kb: 89600,
            parent_pid: Some(999),
            parent_name: Some("bash".to_string()),
            is_dev_runtime: true,
            score: 90,
        }
    }

    #[test]
    fn test_uptime_display_hours() {
        let p = make_process();
        let display = p.uptime_display();
        assert!(display.contains("h"), "expected hours: {}", display);
    }

    #[test]
    fn test_memory_display_mb() {
        let p = make_process();
        assert_eq!(p.memory_display(), "87.5 MB");
    }

    #[test]
    fn test_ports_display() {
        let p = make_process();
        assert_eq!(p.ports_display(), "3000, 3001");
    }

    #[test]
    fn test_ports_display_empty() {
        let mut p = make_process();
        p.ports = vec![];
        assert_eq!(p.ports_display(), "");
    }
}
```

**Step 2: Add `mod process_info;` to `src/main.rs`**

```rust
mod process_info;

fn main() {
    println!("ccpclean");
}
```

**Step 3: Run the tests**

```bash
cargo test process_info
```

Expected: 4 tests pass.

**Step 4: Commit**

```bash
git add src/process_info.rs src/main.rs
git commit -m "feat: add ProcessInfo struct with display helpers"
```

---

### Task 3: Filter Module

**Files:**
- Create: `src/filter.rs`
- Modify: `src/main.rs` (add `mod filter;`)

**Step 1: Create `src/filter.rs`**

```rust
use crate::process_info::ProcessInfo;

const DEV_RUNTIMES: &[&str] = &[
    "node", "nodejs", "python", "python3", "python3.11", "python3.12",
    "deno", "bun", "ruby", "java", "gradle", "mvn",
];

const DEV_PARENT_NAMES: &[&str] = &["claude", "bash", "zsh", "sh", "fish", "pwsh", "powershell"];

const DEV_CMD_KEYWORDS: &[&str] = &[
    "server", "serve", "dev", "run", "start", "manage", "app", "api",
    "http", "web", "watch",
];

pub fn is_dev_runtime(name: &str) -> bool {
    let lower = name.to_lowercase();
    DEV_RUNTIMES.iter().any(|&r| lower == r || lower.starts_with(r))
}

pub fn compute_score(p: &ProcessInfo) -> u8 {
    let mut score: u16 = 0;

    // +30 for dev runtime
    if p.is_dev_runtime {
        score += 30;
    }

    // +20 for port in typical dev range
    if p.ports.iter().any(|&port| port >= 1024 && port <= 9999) {
        score += 20;
    }

    // +20 for dev keywords in command
    let cmd_str = p.cmd.join(" ").to_lowercase();
    if DEV_CMD_KEYWORDS.iter().any(|&kw| cmd_str.contains(kw)) {
        score += 20;
    }

    // +20 for dev parent process
    if let Some(ref parent) = p.parent_name {
        let parent_lower = parent.to_lowercase();
        if DEV_PARENT_NAMES.iter().any(|&pn| parent_lower.contains(pn)) {
            score += 20;
        }
    }

    // +10 for uptime > 30 minutes
    if p.uptime().as_secs() > 1800 {
        score += 10;
    }

    score.min(100) as u8
}

pub fn score_display(score: u8) -> String {
    let filled = (score as usize * 5 / 100).min(5);
    let empty = 5 - filled;
    format!("{}{}", "●".repeat(filled), "○".repeat(empty))
}

#[derive(Clone, Copy, PartialEq)]
pub enum FilterMode {
    Strict, // only dev runtimes listening on ports
    Loose,  // all processes listening on any local port
}

pub fn apply_filter(processes: Vec<ProcessInfo>, mode: FilterMode) -> Vec<ProcessInfo> {
    processes
        .into_iter()
        .filter(|p| {
            if p.ports.is_empty() {
                return false;
            }
            match mode {
                FilterMode::Strict => p.is_dev_runtime,
                FilterMode::Loose => true,
            }
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::process_info::ProcessInfo;
    use std::time::{SystemTime, UNIX_EPOCH};

    fn make_proc(name: &str, ports: Vec<u16>, cmd: Vec<&str>, parent: Option<&str>) -> ProcessInfo {
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();
        let is_dev = is_dev_runtime(name);
        ProcessInfo {
            pid: 1,
            name: name.to_string(),
            cmd: cmd.iter().map(|s| s.to_string()).collect(),
            ports,
            start_time_secs: now - 3600,
            memory_kb: 1024,
            parent_pid: None,
            parent_name: parent.map(|s| s.to_string()),
            is_dev_runtime: is_dev,
            score: 0,
        }
    }

    #[test]
    fn test_is_dev_runtime_node() {
        assert!(is_dev_runtime("node"));
        assert!(is_dev_runtime("Node"));
        assert!(is_dev_runtime("python3"));
        assert!(!is_dev_runtime("nginx"));
        assert!(!is_dev_runtime("postgres"));
    }

    #[test]
    fn test_score_dev_runtime_with_port() {
        let mut p = make_proc("node", vec![3000], vec!["node", "server.js"], Some("bash"));
        p.score = compute_score(&p);
        // +30 (runtime) +20 (port) +20 (cmd keyword "server") +20 (parent bash) +10 (uptime) = 100
        assert_eq!(p.score, 100);
    }

    #[test]
    fn test_score_no_dev_runtime() {
        let mut p = make_proc("nginx", vec![80], vec!["nginx"], None);
        p.score = compute_score(&p);
        // +20 (port 80 is < 1024, so no port score) = 0
        assert_eq!(p.score, 0);
    }

    #[test]
    fn test_score_python_dev_port() {
        let mut p = make_proc("python3", vec![8000], vec!["python3", "manage.py", "runserver"], None);
        p.score = compute_score(&p);
        // +30 (runtime) +20 (port 8000) +20 (cmd "server") +10 (uptime) = 80
        assert_eq!(p.score, 80);
    }

    #[test]
    fn test_score_display() {
        assert_eq!(score_display(100), "●●●●●");
        assert_eq!(score_display(0), "○○○○○");
        assert_eq!(score_display(60), "●●●○○");
    }

    #[test]
    fn test_filter_strict_excludes_nginx() {
        let nginx = make_proc("nginx", vec![8080], vec!["nginx"], None);
        let node = make_proc("node", vec![3000], vec!["node", "app.js"], None);
        let result = apply_filter(vec![nginx, node], FilterMode::Strict);
        assert_eq!(result.len(), 1);
        assert_eq!(result[0].name, "node");
    }

    #[test]
    fn test_filter_loose_includes_all_with_ports() {
        let nginx = make_proc("nginx", vec![8080], vec!["nginx"], None);
        let node = make_proc("node", vec![3000], vec!["node", "app.js"], None);
        let no_port = make_proc("python3", vec![], vec!["python3", "script.py"], None);
        let result = apply_filter(vec![nginx, node, no_port], FilterMode::Loose);
        assert_eq!(result.len(), 2);
    }

    #[test]
    fn test_filter_excludes_no_port_processes() {
        let p = make_proc("node", vec![], vec!["node", "worker.js"], None);
        let result = apply_filter(vec![p], FilterMode::Strict);
        assert!(result.is_empty());
    }
}
```

**Step 2: Add `mod filter;` to `src/main.rs`**

**Step 3: Run the tests**

```bash
cargo test filter
```

Expected: all 9 tests pass. Fix `test_score_no_dev_runtime` if nginx port 80 < 1024 means no port score.

**Step 4: Commit**

```bash
git add src/filter.rs src/main.rs
git commit -m "feat: add filter module with scoring logic"
```

---

### Task 4: Scanner Module

**Files:**
- Create: `src/scanner.rs`
- Modify: `src/main.rs` (add `mod scanner;`)

**Step 1: Create `src/scanner.rs`**

```rust
use std::collections::HashMap;
use sysinfo::System;
use netstat2::{get_sockets_info, AddressFamilyFlags, ProtocolFlags, ProtocolSocketInfo};
use crate::process_info::ProcessInfo;
use crate::filter::is_dev_runtime;

/// Build a map from PID -> list of listening local ports.
fn build_port_map() -> HashMap<u32, Vec<u16>> {
    let mut map: HashMap<u32, Vec<u16>> = HashMap::new();

    let af_flags = AddressFamilyFlags::IPV4 | AddressFamilyFlags::IPV6;
    let proto_flags = ProtocolFlags::TCP;

    if let Ok(sockets) = get_sockets_info(af_flags, proto_flags) {
        for si in sockets {
            if let ProtocolSocketInfo::Tcp(tcp) = si.protocol_socket_info {
                // Only LISTEN state (state == 10 on Windows, or check associated_pids)
                use netstat2::TcpState;
                if tcp.state == TcpState::Listen {
                    let port = tcp.local_port;
                    for pid in &si.associated_pids {
                        map.entry(*pid).or_default().push(port);
                    }
                }
            }
        }
    }

    map
}

pub fn scan() -> Vec<ProcessInfo> {
    let mut sys = System::new_all();
    sys.refresh_all();

    let port_map = build_port_map();

    let mut results = Vec::new();

    for (pid, process) in sys.processes() {
        let pid_u32 = pid.as_u32();
        let ports = port_map.get(&pid_u32).cloned().unwrap_or_default();

        let name = process.name().to_string_lossy().to_string();
        // Strip .exe on Windows
        let name = name.trim_end_matches(".exe").to_string();

        let cmd: Vec<String> = process
            .cmd()
            .iter()
            .map(|s| s.to_string_lossy().to_string())
            .collect();

        let parent_pid = process.parent().map(|p| p.as_u32());
        let parent_name = parent_pid.and_then(|ppid| {
            sys.process(sysinfo::Pid::from_u32(ppid))
                .map(|p| {
                    p.name()
                        .to_string_lossy()
                        .trim_end_matches(".exe")
                        .to_string()
                })
        });

        let is_dev = is_dev_runtime(&name);

        let info = ProcessInfo {
            pid: pid_u32,
            name,
            cmd,
            ports,
            start_time_secs: process.start_time(),
            memory_kb: process.memory() / 1024,
            parent_pid,
            parent_name,
            is_dev_runtime: is_dev,
            score: 0,
        };

        results.push(info);
    }

    results
}
```

**Step 2: Add `mod scanner;` to `src/main.rs`**

**Step 3: Verify it compiles (scanner uses real OS calls, no unit tests needed)**

```bash
cargo build
```

Expected: compiles cleanly.

**Step 4: Quick smoke test in main**

Temporarily add to `main()`:
```rust
fn main() {
    let processes = scanner::scan();
    for p in &processes {
        if !p.ports.is_empty() {
            println!("{} (PID {}) ports: {:?}", p.name, p.pid, p.ports);
        }
    }
}
```

Run `cargo run` and verify processes with ports appear.

**Step 5: Revert main to just `println!("ccpclean");` and commit**

```bash
git add src/scanner.rs src/main.rs
git commit -m "feat: add process scanner with port mapping"
```

---

### Task 5: Killer Module

**Files:**
- Create: `src/killer.rs`
- Modify: `src/main.rs` (add `mod killer;`)

**Step 1: Create `src/killer.rs`**

```rust
use std::io;

#[derive(Debug)]
pub enum KillError {
    PermissionDenied(u32),
    ProcessNotFound(u32),
    Other(u32, io::Error),
}

impl std::fmt::Display for KillError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            KillError::PermissionDenied(pid) => {
                write!(f, "Permission denied killing PID {} (try running as admin)", pid)
            }
            KillError::ProcessNotFound(pid) => {
                write!(f, "Process {} not found (already exited?)", pid)
            }
            KillError::Other(pid, e) => write!(f, "Failed to kill PID {}: {}", pid, e),
        }
    }
}

pub fn kill(pid: u32) -> Result<(), KillError> {
    use sysinfo::{Pid, Signal, System};
    let mut sys = System::new();
    sys.refresh_processes(sysinfo::ProcessesToUpdate::All, true);

    let sysinfo_pid = Pid::from_u32(pid);
    match sys.process(sysinfo_pid) {
        None => Err(KillError::ProcessNotFound(pid)),
        Some(process) => {
            if process.kill_with(Signal::Term).is_none() {
                // SIGTERM not available on this platform, try Kill
                if !process.kill() {
                    return Err(KillError::PermissionDenied(pid));
                }
            }
            Ok(())
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_kill_nonexistent_pid() {
        // PID 0 and very large PIDs generally don't exist
        let result = kill(99999999);
        assert!(matches!(result, Err(KillError::ProcessNotFound(_))));
    }

    #[test]
    fn test_kill_error_display() {
        let e = KillError::PermissionDenied(1234);
        assert!(e.to_string().contains("1234"));
        assert!(e.to_string().contains("admin"));
    }
}
```

**Step 2: Add `mod killer;` to `src/main.rs`**

**Step 3: Run tests**

```bash
cargo test killer
```

Expected: 2 tests pass.

**Step 4: Commit**

```bash
git add src/killer.rs src/main.rs
git commit -m "feat: add cross-platform process killer"
```

---

### Task 6: TUI App State

**Files:**
- Create: `src/tui/mod.rs`
- Modify: `src/main.rs` (add `mod tui;`)

**Step 1: Create `src/tui/` directory and `src/tui/mod.rs`**

```rust
pub mod list_view;
pub mod detail_view;

use crate::process_info::ProcessInfo;
use crate::filter::FilterMode;

#[derive(Clone, Copy, PartialEq)]
pub enum View {
    List,
    Detail,
}

pub struct AppState {
    pub processes: Vec<ProcessInfo>,
    pub selected_index: usize,   // cursor position
    pub checked: Vec<bool>,      // which items are checked for killing
    pub view: View,
    pub filter_mode: FilterMode,
    pub status_message: Option<String>, // transient feedback
    pub should_quit: bool,
}

impl AppState {
    pub fn new(processes: Vec<ProcessInfo>) -> Self {
        let len = processes.len();
        Self {
            processes,
            selected_index: 0,
            checked: vec![false; len],
            view: View::List,
            filter_mode: FilterMode::Strict,
            status_message: None,
            should_quit: false,
        }
    }

    pub fn move_up(&mut self) {
        if self.selected_index > 0 {
            self.selected_index -= 1;
        }
    }

    pub fn move_down(&mut self) {
        if self.selected_index + 1 < self.processes.len() {
            self.selected_index += 1;
        }
    }

    pub fn toggle_checked(&mut self) {
        if let Some(v) = self.checked.get_mut(self.selected_index) {
            *v = !*v;
        }
    }

    pub fn select_all(&mut self) {
        let all_checked = self.checked.iter().all(|&c| c);
        let target = !all_checked;
        self.checked.iter_mut().for_each(|c| *c = target);
    }

    pub fn checked_pids(&self) -> Vec<u32> {
        self.processes
            .iter()
            .zip(self.checked.iter())
            .filter(|(_, &checked)| checked)
            .map(|(p, _)| p.pid)
            .collect()
    }

    pub fn current_process(&self) -> Option<&ProcessInfo> {
        self.processes.get(self.selected_index)
    }

    pub fn switch_view(&mut self) {
        self.view = match self.view {
            View::List => View::Detail,
            View::Detail => View::List,
        };
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::process_info::ProcessInfo;
    use std::time::{SystemTime, UNIX_EPOCH};

    fn make_app() -> AppState {
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
        let processes = vec![
            ProcessInfo { pid: 1, name: "node".to_string(), cmd: vec![], ports: vec![3000], start_time_secs: now, memory_kb: 0, parent_pid: None, parent_name: None, is_dev_runtime: true, score: 80 },
            ProcessInfo { pid: 2, name: "python".to_string(), cmd: vec![], ports: vec![8000], start_time_secs: now, memory_kb: 0, parent_pid: None, parent_name: None, is_dev_runtime: true, score: 60 },
        ];
        AppState::new(processes)
    }

    #[test]
    fn test_move_up_clamped() {
        let mut app = make_app();
        app.move_up(); // already at 0
        assert_eq!(app.selected_index, 0);
    }

    #[test]
    fn test_move_down_then_up() {
        let mut app = make_app();
        app.move_down();
        assert_eq!(app.selected_index, 1);
        app.move_down(); // clamped at last
        assert_eq!(app.selected_index, 1);
        app.move_up();
        assert_eq!(app.selected_index, 0);
    }

    #[test]
    fn test_toggle_checked() {
        let mut app = make_app();
        assert!(!app.checked[0]);
        app.toggle_checked();
        assert!(app.checked[0]);
        app.toggle_checked();
        assert!(!app.checked[0]);
    }

    #[test]
    fn test_select_all_and_deselect() {
        let mut app = make_app();
        app.select_all();
        assert!(app.checked.iter().all(|&c| c));
        app.select_all(); // all checked -> uncheck all
        assert!(app.checked.iter().all(|&c| !c));
    }

    #[test]
    fn test_checked_pids() {
        let mut app = make_app();
        app.checked[0] = true;
        assert_eq!(app.checked_pids(), vec![1]);
    }

    #[test]
    fn test_switch_view() {
        let mut app = make_app();
        assert_eq!(app.view, View::List);
        app.switch_view();
        assert_eq!(app.view, View::Detail);
        app.switch_view();
        assert_eq!(app.view, View::List);
    }
}
```

**Step 2: Add `mod tui;` to `src/main.rs`**

**Step 3: Run tests**

```bash
cargo test tui
```

Expected: 6 tests pass.

**Step 4: Commit**

```bash
git add src/tui/mod.rs src/main.rs
git commit -m "feat: add TUI app state with navigation and selection"
```

---

### Task 7: TUI List View

**Files:**
- Create: `src/tui/list_view.rs`

**Step 1: Create `src/tui/list_view.rs`**

```rust
use ratatui::{
    layout::{Constraint, Direction, Layout, Rect},
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{Block, Borders, Cell, Row, Table, TableState, Paragraph},
    Frame,
};
use crate::filter::{score_display, FilterMode};
use super::AppState;

pub fn render(f: &mut Frame, area: Rect, state: &AppState) {
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([Constraint::Min(5), Constraint::Length(2)])
        .split(area);

    render_table(f, chunks[0], state);
    render_footer(f, chunks[1], state);
}

fn render_table(f: &mut Frame, area: Rect, state: &AppState) {
    let mode_str = match state.filter_mode {
        FilterMode::Strict => "Strict",
        FilterMode::Loose => "Loose",
    };
    let title = format!(" ccpclean  [{}]  Tab=detail view  F=toggle mode ", mode_str);

    let header = Row::new(vec![
        Cell::from("  "),
        Cell::from("PID"),
        Cell::from("Name"),
        Cell::from("Ports"),
        Cell::from("Score"),
        Cell::from("Command"),
    ])
    .style(Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD));

    let rows: Vec<Row> = state
        .processes
        .iter()
        .enumerate()
        .map(|(i, p)| {
            let is_selected = i == state.selected_index;
            let is_checked = state.checked[i];

            let checkbox = if is_checked { "[x]" } else { "[ ]" };
            let cmd_preview = p.cmd.get(1).map(|s| s.as_str()).unwrap_or("");

            let row_style = if is_selected {
                Style::default().bg(Color::DarkGray)
            } else {
                Style::default()
            };

            Row::new(vec![
                Cell::from(checkbox),
                Cell::from(p.pid.to_string()),
                Cell::from(p.name.clone()),
                Cell::from(p.ports_display()),
                Cell::from(score_display(p.score)),
                Cell::from(cmd_preview.to_string()),
            ])
            .style(row_style)
        })
        .collect();

    let widths = [
        Constraint::Length(5),
        Constraint::Length(8),
        Constraint::Length(12),
        Constraint::Length(16),
        Constraint::Length(7),
        Constraint::Min(20),
    ];

    let table = Table::new(rows, widths)
        .header(header)
        .block(Block::default().borders(Borders::ALL).title(title));

    let mut table_state = TableState::default().with_selected(Some(state.selected_index));
    f.render_stateful_widget(table, area, &mut table_state);
}

fn render_footer(f: &mut Frame, area: Rect, state: &AppState) {
    let msg = if let Some(ref s) = state.status_message {
        s.clone()
    } else {
        " Space=toggle  A=all  Enter=kill selected  Q=quit".to_string()
    };
    let p = Paragraph::new(msg).style(Style::default().fg(Color::DarkGray));
    f.render_widget(p, area);
}
```

**Step 2: Verify it compiles**

```bash
cargo build
```

**Step 3: Commit**

```bash
git add src/tui/list_view.rs
git commit -m "feat: add TUI list view with checkbox table"
```

---

### Task 8: TUI Detail View

**Files:**
- Create: `src/tui/detail_view.rs`

**Step 1: Create `src/tui/detail_view.rs`**

```rust
use ratatui::{
    layout::{Constraint, Direction, Layout, Rect},
    style::{Color, Modifier, Style},
    widgets::{Block, Borders, List, ListItem, ListState, Paragraph},
    Frame,
};
use crate::filter::{score_display, FilterMode};
use super::AppState;

pub fn render(f: &mut Frame, area: Rect, state: &AppState) {
    let chunks = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([Constraint::Length(26), Constraint::Min(40)])
        .split(area);

    render_process_list(f, chunks[0], state);
    render_detail_panel(f, chunks[1], state);
}

fn render_process_list(f: &mut Frame, area: Rect, state: &AppState) {
    let items: Vec<ListItem> = state
        .processes
        .iter()
        .map(|p| {
            let label = format!("{:<10} :{}", p.name, p.ports_display());
            ListItem::new(label)
        })
        .collect();

    let mode_str = match state.filter_mode {
        FilterMode::Strict => "Strict",
        FilterMode::Loose => "Loose",
    };

    let list = List::new(items)
        .block(Block::default().borders(Borders::ALL).title(format!(" [{}] Tab=list ", mode_str)))
        .highlight_style(Style::default().bg(Color::DarkGray).add_modifier(Modifier::BOLD))
        .highlight_symbol("▶ ");

    let mut list_state = ListState::default().with_selected(Some(state.selected_index));
    f.render_stateful_widget(list, area, &mut list_state);
}

fn render_detail_panel(f: &mut Frame, area: Rect, state: &AppState) {
    let content = match state.current_process() {
        None => "No process selected".to_string(),
        Some(p) => {
            let parent_str = match (&p.parent_name, p.parent_pid) {
                (Some(name), Some(pid)) => format!("{} (PID {})", name, pid),
                _ => "unknown".to_string(),
            };
            format!(
                "PID:        {}\nName:       {}\nPorts:      {}\nCommand:    {}\nStarted:    {}\nMemory:     {}\nParent:     {}\nConfidence: {} {}\n\n[Enter] Kill   [Q] Quit",
                p.pid,
                p.name,
                p.ports_display(),
                p.cmd.join(" "),
                p.uptime_display(),
                p.memory_display(),
                parent_str,
                score_display(p.score),
                if p.score >= 70 { "High" } else if p.score >= 40 { "Medium" } else { "Low" },
            )
        }
    };

    let paragraph = Paragraph::new(content)
        .block(Block::default().borders(Borders::ALL).title(" Process Detail "));
    f.render_widget(paragraph, area);
}
```

**Step 2: Verify it compiles**

```bash
cargo build
```

**Step 3: Commit**

```bash
git add src/tui/detail_view.rs
git commit -m "feat: add TUI two-panel detail view"
```

---

### Task 9: TUI Event Loop

**Files:**
- Create: `src/tui/runner.rs`
- Modify: `src/tui/mod.rs` (add `pub mod runner;` and event loop)

**Step 1: Add `pub mod runner;` to `src/tui/mod.rs`**

**Step 2: Create `src/tui/runner.rs`**

```rust
use std::io;
use std::time::Duration;
use crossterm::{
    event::{self, DisableMouseCapture, EnableMouseCapture, Event, KeyCode},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{backend::CrosstermBackend, Terminal};
use crate::killer;
use super::{AppState, View, list_view, detail_view};

pub fn run(mut state: AppState) -> io::Result<()> {
    enable_raw_mode()?;
    let mut stdout = io::stdout();
    execute!(stdout, EnterAlternateScreen, EnableMouseCapture)?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;

    let result = run_loop(&mut terminal, &mut state);

    disable_raw_mode()?;
    execute!(
        terminal.backend_mut(),
        LeaveAlternateScreen,
        DisableMouseCapture
    )?;
    terminal.show_cursor()?;

    result
}

fn run_loop<B: ratatui::backend::Backend>(
    terminal: &mut Terminal<B>,
    state: &mut AppState,
) -> io::Result<()> {
    loop {
        terminal.draw(|f| {
            let area = f.area();
            match state.view {
                View::List => list_view::render(f, area, state),
                View::Detail => detail_view::render(f, area, state),
            }
        })?;

        if event::poll(Duration::from_millis(50))? {
            if let Event::Key(key) = event::read()? {
                // Clear previous status message on any key
                state.status_message = None;

                match key.code {
                    KeyCode::Char('q') | KeyCode::Esc => {
                        state.should_quit = true;
                        break;
                    }
                    KeyCode::Tab => state.switch_view(),
                    KeyCode::Up | KeyCode::Char('k') => state.move_up(),
                    KeyCode::Down | KeyCode::Char('j') => state.move_down(),
                    KeyCode::Char(' ') => state.toggle_checked(),
                    KeyCode::Char('a') | KeyCode::Char('A') => state.select_all(),
                    KeyCode::Char('f') | KeyCode::Char('F') => {
                        use crate::filter::FilterMode;
                        state.filter_mode = match state.filter_mode {
                            FilterMode::Strict => FilterMode::Loose,
                            FilterMode::Loose => FilterMode::Strict,
                        };
                    }
                    KeyCode::Enter => {
                        let pids = state.checked_pids();
                        if pids.is_empty() {
                            // In detail view, kill current process
                            if state.view == View::Detail {
                                if let Some(p) = state.current_process() {
                                    let pid = p.pid;
                                    handle_kill(state, pid);
                                }
                            } else {
                                state.status_message = Some(" No processes selected (use Space to check)".to_string());
                            }
                        } else {
                            let mut errors = vec![];
                            for pid in pids {
                                if let Err(e) = killer::kill(pid) {
                                    errors.push(e.to_string());
                                }
                            }
                            if errors.is_empty() {
                                state.status_message = Some(" Killed selected processes.".to_string());
                                // Rescan would happen at app level; for now just clear checks
                                state.checked.iter_mut().for_each(|c| *c = false);
                            } else {
                                state.status_message = Some(format!(" Errors: {}", errors.join("; ")));
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
    }
    Ok(())
}

fn handle_kill(state: &mut AppState, pid: u32) {
    match killer::kill(pid) {
        Ok(_) => {
            state.status_message = Some(format!(" Killed PID {}.", pid));
            state.checked.iter_mut().for_each(|c| *c = false);
        }
        Err(e) => {
            state.status_message = Some(format!(" {}", e));
        }
    }
}
```

**Step 3: Compile check**

```bash
cargo build
```

Expected: compiles cleanly.

**Step 4: Commit**

```bash
git add src/tui/runner.rs src/tui/mod.rs
git commit -m "feat: add TUI event loop with keyboard handling"
```

---

### Task 10: CLI Args + Main Integration

**Files:**
- Create: `src/cli.rs`
- Modify: `src/main.rs` (wire everything together)

**Step 1: Create `src/cli.rs`**

```rust
use clap::Parser;

#[derive(Parser, Debug)]
#[command(
    name = "ccpclean",
    version,
    about = "Scan and clean up orphaned local web service processes",
    long_about = None
)]
pub struct Cli {
    /// Loose mode: show all processes listening on local ports (default: strict - dev runtimes only)
    #[arg(short = 'a', long = "all")]
    pub all: bool,

    /// Filter by specific port
    #[arg(short = 'p', long = "port")]
    pub port: Option<u16>,

    /// Non-interactive: print list and exit
    #[arg(long = "no-tui")]
    pub no_tui: bool,
}
```

**Step 2: Replace `src/main.rs` with full integration**

```rust
mod cli;
mod filter;
mod killer;
mod process_info;
mod scanner;
mod tui;

use clap::Parser;
use cli::Cli;
use filter::{apply_filter, compute_score, FilterMode};
use tui::{AppState, runner};

fn main() {
    let cli = Cli::parse();

    let mode = if cli.all {
        FilterMode::Loose
    } else {
        FilterMode::Strict
    };

    // Scan processes
    let mut processes = scanner::scan();

    // Compute scores
    for p in &mut processes {
        p.score = compute_score(p);
    }

    // Apply filter
    let mut processes = apply_filter(processes, mode);

    // Apply port filter if specified
    if let Some(port) = cli.port {
        processes.retain(|p| p.ports.contains(&port));
    }

    // Sort by score descending
    processes.sort_by(|a, b| b.score.cmp(&a.score));

    if cli.no_tui {
        // Non-interactive output
        println!("{:<8} {:<12} {:<18} {:<7} {}", "PID", "NAME", "PORTS", "SCORE", "COMMAND");
        println!("{}", "-".repeat(70));
        for p in &processes {
            let cmd = p.cmd.get(1).map(|s| s.as_str()).unwrap_or("");
            println!(
                "{:<8} {:<12} {:<18} {:<7} {}",
                p.pid,
                p.name,
                p.ports_display(),
                p.score,
                cmd
            );
        }
        return;
    }

    if processes.is_empty() {
        println!("No matching processes found.");
        return;
    }

    let mut state = AppState::new(processes);
    state.filter_mode = mode;

    if let Err(e) = runner::run(state) {
        eprintln!("TUI error: {}", e);
        std::process::exit(1);
    }
}
```

**Step 3: Build and run a smoke test**

```bash
cargo build
cargo run -- --no-tui
```

Expected: prints a table of listening processes (may be empty, should not crash).

```bash
cargo run -- --all --no-tui
```

Expected: prints more processes.

**Step 4: Run the TUI**

```bash
cargo run
```

Expected: TUI opens, shows processes, Tab switches views, Q exits.

**Step 5: Commit**

```bash
git add src/cli.rs src/main.rs
git commit -m "feat: wire CLI args and main integration"
```

---

### Task 11: README and crates.io Metadata

**Files:**
- Create: `README.md`
- Modify: `Cargo.toml` (ensure metadata complete)

**Step 1: Create `README.md`**

````markdown
# ccpclean

Scan and clean up orphaned local web service processes — e.g. Node, Python, Deno, Bun servers left running after your dev session ends.

## Install

```bash
cargo install ccpclean
```

## Usage

```bash
# Interactive TUI (strict mode: dev runtimes only)
ccpclean

# Show all listening processes (loose mode)
ccpclean --all

# Filter by port
ccpclean --port 3000

# Non-interactive list
ccpclean --no-tui
```

## TUI Keybindings

| Key | Action |
|-----|--------|
| `↑`/`↓` or `j`/`k` | Navigate |
| `Space` | Toggle selection |
| `A` | Select / deselect all |
| `Enter` | Kill selected processes |
| `Tab` | Switch between list and detail view |
| `F` | Toggle strict / loose filter mode |
| `Q` / `Esc` | Quit |

## License

MIT
````

**Step 2: Verify Cargo.toml has all crates.io required fields**

Ensure these fields are present: `description`, `license`, `repository`, `keywords`, `categories`.

**Step 3: Final build check**

```bash
cargo build --release
```

Expected: release binary at `target/release/ccpclean.exe` (Windows) or `target/release/ccpclean`.

**Step 4: Commit**

```bash
git add README.md Cargo.toml
git commit -m "docs: add README and crates.io metadata"
```

---

## Local Install

```bash
cargo install --path .
ccpclean --help
```

## Publishing to crates.io

```bash
cargo login
cargo publish --dry-run
cargo publish
```
